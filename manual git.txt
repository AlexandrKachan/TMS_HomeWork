Помещение файла в репозиторий
После того как мы создали файл его надо подготовить для фиксации и зафиксировать в репозитории, то есть закомитить. Подготовить для фиксации это означает, что его надо проиндексировать командой git add:

git add *

Проиндексированный файл это еще не означает, что он закомичен, это означает, что он готов для коммита в репозиторий, а сам коммит выполняется командой git commit:

git commit -m "create project"

Перенос изменений на удаленный репозиторий
Локальный репозиторий готов, теперь осталось перенести его на удаленный. Переносится репозиторий командой git push, но прежде чем переносить мы должны выяснить со сколькими репозиториями мы работаем и выбрать из списка тот, в который мы хотим перенести наши изменения. Для того, чтобы увидеть все удаленные репозитории нужно выполнить команду git remote -v:

git remote -v
origin  https://github.com/your_account/your_project (fetch)
origin  https://github.com/your_account/your_project (push)
Но мы увидим удаленные репозитории только в том случае, если мы с клонировали его командой git clone, в случае если мы создали локальный репозиторий командой git init, то мы ничего не увидим, в этом случае нам надо добавить удаленный репозиторий, это будет далее. А сейчас, допустим у нас есть клон удалённого репозитория. Выполнив команду git remote -v мы увидим url адреса и короткое имя для удалённых репозиториев с которыми мы работаем. В данном случае мы работаем с одним удаленным репозиторием, которому присвоено короткое имя по умолчанию origin, который находится по адресу https://github.com/your_account/your_project как для фетча, так и для пуша.
Теперь можем переносить все изменения для репозитория origin командой git push:

git push origin //master

Username for 'https://github.com': dev-blogs
Password for 'https://dev-blogs@github.com': 
To https://github.com/dev-blogs/your_project
   eeb0736..412c945  master -> master
После этого github запросит имя юзера и пароль.
То что мы сейчас сделали мы запушили (выложили) наши локальные изменения на удаленный репозиторий у которого айдишник origin в ветку master.



***********************************************************

https://javarush.ru/groups/posts/2683-nachalo-rabotih-s-git-podrobnihy-gayd-dlja-novichkov


*************************

Таким образом видно, какие файлы изменены, но еще не добавлены в состояние staged. Чтобы добавить их в состояние staged, нужно написать git add. Здесь может быть несколько вариантов, например:
git add -A — добавить все файлы из состояния в staged;
git add . — добавить все файлы из этой папки и все внутренних. По сути тоже самое, что и предыдущее;
git add <имя файла> — добавляет только конкретный файл. Здесь можно пользоваться регулярными выражениями, чтобы добавлять по какому-то шаблону. Например, git add *.java: это значит, что нужно добавить только файлы с расширением java.

Второй способ создания ветки — создание на основе другой. Я хочу создать ветку на основе master ветки, поэтому нужно сперва перейти на нее, а уже следующим шагом — создать новую. Смотрим:
git checkout master — переходим на ветку master;
git status — проверяем, точно ли на мастере.
Вот здесь видно, что мы перешли на master ветку, здесь уже работает гит игнор, и скомпилированный класс уже не светится как untracked.

Теперь создаем новую ветку на основе master ветки:

git checkout -b feature/update-txt-files
Если есть сомнения, что эта ветка будет не такой же, как и master, можно это легко проверить, написав git log и посмотреть на все коммиты. Там их должно быть четыре.
Так вот, на нашем примере, мы создали ветку feature/update-txt-files. Как написано в имени ветки — обновим текст.
Теперь нужно создать под это дело новый коммит:

git add *.txt
git commit -m “updated txt files”
git log
Теперь, если мы хотим смерджить feature/update-txt-files ветку в master, нужно перейти в master и написать git merge feature/update-txt-files:

git checkout master
git merge feature/update-txt-files
git log

Как результат — теперь и в мастер ветке есть коммит, который был добавлен в feature/update-txt-files.

Эта функциональность добавлена, поэтому можно удалить фиче (feature) ветку. Для этого напишем:

git branch -D feature/update-txt-files
///////////////////
Усложняем ситуацию: теперь допустим, что опять нужно изменить txt файл. Но теперь еще и в мастере этот файл будет изменен также. То есть он будет параллельно изменяться, и гит не сможет понять что нужно делать в ситуации, когда мы захотим смерджить в master ветку новый код.

Поехали!

Создаем новую ветку на основе master, делаем изменения в text_resource.txt и создаем коммит под это дело:
git checkout -b feature/add-header
... делаем изменения в файле


!!!!!!!!!!!
Переходим на master ветку и также обновляем этот текстовый файл в той же строке, что и фиче ветка:

git checkout master
… обновили test_resource.txt
git add test_resource.txt
git commit -m “added master header to txt”

И теперь самый интересный момент: нужно смерджить изменения из feature/add-header ветки в master. Мы находимся в мастер ветке, поэтому нужно только написать:

git merge feature/add-header

Но мы получим результат с конфликтом в файле test_resource.txt:





